---
title: 表单验证
date: 2018-1-26 17:48
tags: angular
---

1. 模板驱动的表单

   1. 记得在module中导入FormsModule模块 `import {FormsModule} from '@angular/forms'`

   2. ngForm 指令. 这个指令为form增加了一些额外的特性,控制带有 `ngModel` 指令和 `name` 属性的元素. **使用ngModel时记得定义name属性**  <form #heroForm="ngForm">  

   3. input标签可以加上模板引用变量`#spy` ,他的className有包含输入,touch等动作的css类,重点是校验成功与否的类: `ng-valid ng-invalid` ,可以给他们定义

      <!--more-->

      ```css
      .ng-valid[required], .ng-valid.required  {
        border-left: 5px solid #42A948; /* green */
      }

      .ng-invalid:not(form)  {
        border-left: 5px solid #a94442; /* red */
      }
      ```

   4. 如何提示错误消息,放入相邻的div元素中

      ```css
      <label for="name">Name</label>
      <input type="text" class="form-control" id="name"
             required
             [(ngModel)]="model.name" name="name"
             #name="ngModel">
      <div [hidden]="name.valid || name.pristine"
           class="alert alert-danger">
        Name is required
      </div>
      ```

      另:表单重置可以直接使用reset方法 `heroForm.reset()` heroForm为 *模板引用变量* 

   5. 验证表单是否通过 `heroForm.form.valid` 返回的布尔值

   6. 显示隐藏div有一个hidden属性`<div [hidden]="isValid"></div>` 

   7. 校验的状态  dirty,touched,这两个值都可以从 *模板引用变量*  取得

2. 模型驱动的表单(响应式)

   1. 内置验证器

      响应式表单中应该在组件类中直接把验证器函数添加到FormControl 上

      ```typescript
      this.heroForm = new FormGroup({
          'name': new FormControl(this.hero.name, [
            Validators.required,
            Validators.minLength(4),
            forbiddenNameValidator(/bob/i) // <-- Here's how you pass in the custom validator.
          ])
      ```

      ```html
      //注意formControlName
      <input id="name" class="form-control"
             formControlName="name" required >

      <div *ngIf="name.invalid && (name.dirty || name.touched)"
           class="alert alert-danger">

        <div *ngIf="name.errors.required">
          Name is required.
        </div>
        <div *ngIf="name.errors.minlength">
          Name must be at least 4 characters long.
        </div>
        <div *ngIf="name.errors.forbiddenName">
          Name cannot be Bob.
        </div>
      </div>
      ```

   2. `ngModel` 不是`reactiveFormsModule` 的一部分

   3. 响应式表单是同步的,而模板驱动表单是异步的

   4. FormControl指令可以创建一个fromcontrol的实例,接受三个参数初始值,验证器数组,异步验证器数组,关联到模板`[formControl]="name"` 

   5. formcontrol,formgroup的概念: 简单来说 FormControl用于单独的一个控件  而group则是一组,多个

      - [*FormControl*](https://angular.cn/api/forms/FormControl) 用于跟踪一个*单独的*表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框。
      - [*FormGroup*](https://angular.cn/api/forms/FormGroup)用于 跟踪*一组*`AbstractControl`的实例的值和有效性状态。 该组的属性中包含了它的子控件。 组件中的顶级表单就是一个`FormGroup`。
      - [*FormArray*](https://angular.cn/api/forms/FormArray)用于跟踪`AbstractControl`实例组成的有序数组的值和有效性状态。
      - [`AbstractControl`](https://angular.cn/api/forms/AbstractControl)是三个具体表单类的抽象基类。 并为它们提供了一些共同的行为和属性，其中有些是*可观察对象（Observable）*。

   6. FormGroup:放有多个FormControl,绑定到模板`[formGroup]=heroForm`  ,formGroup 是一个响应式表单的指令,他可以拿到FormGroup 实例,有了FormGroup后需要加上`formControlName=name` ,这才能关联上

      ```typescript
      export class Component2{
        heroForm = new FormGroup({
          name:new FormControl()
        })
      }
      ```

   7. FormBuilder 类,使用方法

      ```typescript
      export class HeroDetailComponent3 {
        heroForm: FormGroup; // 1 声明类型

        constructor(private fb: FormBuilder) { // <--- 2 注入 FormBuilder
          this.createForm(); //4 调用createForm方法
        }
      //3 添加一个createForm方法
        createForm() {
          this.heroForm = this.fb.group({
            name: '', // <--- the FormControl called "name" ['初始值',校验规则]
            age:['',Validators.required]  //Validators用于校验,可以用hero.status验证有效性
          });
        }
      }
      ```

      ```flow
      st=>start: 声明类型
      op1=>operation: 注入 FormBuilder
      op2=>operation: 添加一个createForm方法
      e=>end: 在构造函数中调用

      st(right)->op1(right)->op2(right)->e
      ```

   8. 查看一个单独空间的状态 

      ```
      Name value: {{ heroForm.get('name').value }}
      ```

      ​


